# x32CallX64
如何在易语言中执行64位代码

#wow64工作原理

wow64子系统实际上是一个wow64.exe，其先把32位应用映射到wow64.exe的地址空间，然后更改cpu执行流来实现32位程序的运行，其中，wow64系统相当于32位系统的内核，在wow64cpu.dll里实现线程切换，这是通过维护32位的peb和teb实现的

因此，进程实际上有自己的peb64和teb64，在进行系统调用时就切换到线程的64位环境，之后再切换回32位环境

#实现原理

模拟线程切换，先将寄存器保存到堆栈 -> 读取参数 - > call nt64.fn/syscall id -> 恢复寄存器

#实现效果

可以让易语言直接调用nt64的函数（因为ntdll64是真实存在的），如给64位线程创建线程、释放虚拟内存

#待改进

无法调用win32u.dll函数，需要自己实现

#32位进程的user32函数调用原理

32位进程的win32u_64.dll实际上是wow64win.dll，该dll会直接先使用syscall请求系统服务，但会因为异常直接返回到wow64win.dll的一个回调入口，这个回调函数会查一张函数表进行真实的win32函数调用，估计是做一个堆栈扩展，然后执行

调用操作，重写的时候需要先申请一个大的堆栈，然后再执行syscall，但因为没有应用价值所以没有继续更新

#提示

64位代码需要使用64位编译器编译，之后把编译好的代码复制到32.asm后再使用32位编译器编译
